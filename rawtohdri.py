#!/usr/bin/env python2.7
##############################################################################
### User configurable stuff ##################################################
##############################################################################
# Define maximum number of processes to run at once (multiprocessing threads)
# ( at present, rawtohdri never runs more processes than the chunk size. )
MAX_WORKERS = 3

# Define Temp DIR for intermediate 16 bit ppm files generated by dcraw. For
# best performance, this should be a different spindle than the out exr
# If you have the RAM for it, /dev/shm/ may be faster than disk

#TEMP_DIR = '/dev/shm/'
TEMP_DIR = '/tmp/'

# Rotate image amount [0,90,180,270] empty str = camera sensor angle
ROTATE = '-t 270 '
# ROTATE = ' '

##############################################################################
####### END OF USER CONFIGURABLE STUFF #######################################
##############################################################################
""" 
    rawtohdri - A tool for stacking camera raws into OpenEXR HDR images
         Copyright 2011 Aaron Estrada  |  bin.echo@gmail.com
         
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>
"""
VERSION = '0.1.0'
import os, sys, getopt, argparse
import numpy as np
import OpenEXR, Imath
from multiprocessing import Pool
from subprocess import Popen, PIPE

def oops():
        print """
        Oops! You got some arguments wrong..."""
        

epilog = """rawtohdri Version: " + VERSION + "Copyright 2011 Aaron Estrada bin.echo@gmail.com

raw2hdri batch-processes bracketed camera RAW files into exr format HDR images. It works with any raw file format dcraw supports. The only required argument is INPUT_RAW_DIR, in which case the default behavior is to dump the resulting HDRIs in the INPUT_RAW_DIR with the file name hdrout_%04d.exr . The output images may alternately be nested in a dir named exr inside the input dir using the -n flag.  The size of the bracket steps may be set with the -e flag ( Default = ev 3 ). raw2hdri assumes bracketed images are ordered darkest exposure to brightest. """

parser = argparse.ArgumentParser(description=' Usage: stacker [OPTION] INPUT_RAW_DIR', epilog=epilog)

parser.add_argument('-x', "--chunk", dest="chunk", default=3, type=int, help='Number of images per HDR stack')
parser.add_argument('-e', "--ev", dest="ev", default=3, type=int, help='Bracket ev')
parser.add_argument("-c", "--center", dest="center", default = 2, help= "second exposure")
parser.add_argument("-n", "--nest", dest="nest", default = False, action="store_true", 
		    help= 'Nest output images in dir named "exr" in input dir')
parser.add_argument("-o", "--out-basename", dest="output_basename", default="hdrout_%04d.exr")
parser.add_argument("-d", "--out-dir", dest="output_images_dir", default=None)
parser.add_argument("-v", dest="verbose_dcraw", default=False, action="store_true", help="turn on dcraw verbose output.")
parser.add_argument("--lo", dest="lo", type=float, default = 0.70, help="Lowest value to be clipped.")
parser.add_argument("--hi", dest="hi", type=float, default = 0.80, help="Highest value to be clipped.")
parser.add_argument("input_dir", help="Directory to process")

def usage(v = 0):
	parser.print_help()
	sys.exit()

def getargv():
        """Returns args as dict ( key:value pairs ) """

	args = parser.parse_args().__dict__                
        
        if args['nest'] == True:
                args['output_dir'] = args['input_dir']+'exr'
        # Make sure ouput_dir has something useful in it no matter what
        if 'output_dir' not in args:
                args['output_dir'] = args['input_dir']               
        
        """ print debugging info
        print 'ARGV      :', argv
        print 'OPTIONS   :', options
        print 'REMAINING :', remainder
        print 'CHUNK     :', args['chunk']
        print 'EV        :', args['ev']
        print 'LO        :', args['lo']
        print 'HI        :', args['hi']
        print 'NEST      :', args['nest']
        print 'INPUTDIR  :', args['input_dir']
        print 'OUTPUTDIR :', args['output_dir']
        print 'OUTPUTNAME:', args['output_basename']
        print 'VERBOSE   :', args['verbose']
        """
        return(args)


def getFiles(d):
    """Get list of files from directory 'd' and returns list of those files with absolute path from /"""
    return [os.path.join(d, f) for f in sorted(os.listdir(d)) if f.lower().endswith("cr2")]

def getMeta(file):
    """Get metadata from raw file using dcraw. Returns dict."""
    COMMAND = 'dcraw -i -v '+file
    f = os.popen(COMMAND)
    parsed = f.read().split('\n')
    f.close()
    parsed.remove('')
    parsed.remove('')
    data = []
    for i in parsed:
        m = i.split(': ')
        data.append(m[1])
    meta = dict()
    for n, label in enumerate(['date' ,'camera' ,'iso' ,'shutter' ,'aperture' ,'focal']):
	    meta[label] = data[n+1]
    return meta

def chunk(l, n):
    """
    Yield successive n-sized chunks from list or string. ( Using a Generator )
    Examples: 
    print(list(chunk(range(75), 10)))
    lol = [group for group in chunk(array, 3)]
    chopping up a string into an array: myArray = [group for group in chunk(string, 5)]
    """ 
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

def sh(cmd):
    """
    cmd must be structured /exactly/ as /bin/sh would expect to see it. (Including any escapes etc.) 
    Calls /bin/sh and waits for subprocess to complete before exiting.
    This is basically just a wrapper so we can use Pool.map() method with shell=True
    We use shell=True to encapsulate the pipes and stuff used by our shell one-liners.
    """
    p = Popen(cmd, stdout=PIPE, shell=True)
    sys.stdout.write(p.communicate(input=None)[0])
    sys.stdout.flush()
    Popen.wait(p)

class PPM:
    """Wrapper class for making pythonic ppm read-only file objects.
        Upcasts input depth to float as each line is read.
        Expects file handle as only argument. Returns NumPy array
        of 'float_' (which is Python float64 compatible)
        
        myppm = PPM(file('ppmFile', 'rb'))
        
        Iterator returns next scanline for next().
    """
    def __init__(self, ppmFileObject):
        self.f16 = np.float_(1.0/65535)
        self.f8 = (1.0/255)
        self.data = ppmFileObject
        self.type = self.data.readline().strip()
        self.rez = self.data.readline().strip().split()
        self.colors = int(self.data.readline().strip())
        self.w = int(self.rez[0])
        self.h = int(self.rez[1])
        try: self.type == 'P6'
        except: print 'Only binary ppms are currently supported.'
        if self.colors == 65535:
            self.dtype = np.uint16
            self.depth = 16
        elif self.colors == 255:
            self.dtype = np.uint8
            self.depth = 8
            print 'WARNING: Unsupported PPM depth. Only 16 bit PPMs are currently supported!'
        else:
            self.dtype = np.uint8
            self.depth = 8
            print 'WARNING: Unsupported PPM depth. Assuming byte sized pixels. (Only 16 bit PPMs are currently supported!)'
    
    def __iter__(self):
        self.data.seek(0) # Jumps to head of file and move pointer past header by reading lines since I'm not clever enough to do it some other way.
        self.type = self.data.readline().strip()
        self.rez = self.data.readline().strip().split()
        self.colors = int(self.data.readline().strip())
        self.w = int(self.rez[0])
        self.h = int(self.rez[1])
        self.index = self.h
        return self
    
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.readline()
    
    def readline(self, lines=1):
        """Number lines number of scanlines to read from PPM file.
        Returnes as NumPy Array of floats. It's your job to know how
        many lines there are in the raster and do the right thing when calling
        this function manually. Consider using __iter__() and next() instead.
        """
        return np.fromfile(self.data, dtype=self.dtype, count=(lines * self.w * 3), sep='').byteswap() * self.f16
    
    def read(self, size=None):
        """Read size number pixels, returned as interleaved 1D NumPy array.
        If the size argument is negative or omitted, read until EOF is reached.
        """
        if (size == None) or (size <= 0):
            d = np.fromfile(self.data, dtype=self.dtype, count=-1, sep='').byteswap()
        else:
            d = np.fromfile(self.data, dtype=self.dtype, count=size * 3, sep='').byteswap()
    
	return d * self.f16

    def close(self):
        self.data.close()

def lumaClip(p, lo=0.65, hi=0.85):
	"""
	Makes a matte value for line p based on luma. Expects floating-point input.
	Returns 1 for values under lo. Returns lerped values from 1 to 0 to hi
    lo should always be a lower value than hi ... ie lumaClip(p, 0.8, 0.95)
	"""
	return_value = (hi+(-1*p))/(hi-lo)
	return_value[p >= hi] = 0.0
	return_value[p < hi] = 1.0
	
	return return_value

def ev2ef(ev):
    """Converts stops to linear 'exposure factor'"""
    if ev <= 0:
        return 2.0**abs(ev)
    else:
        return 1.0 / 2**ev

def hdrStackLines(bg, fg, ev, lo=0.65, hi=0.85):
    """
    Generates matte for fg based on lo and hi cut
    Mults fg line values by ev stops and "overs" on bg based on matte
    """
    exposureFactor = ev2ef(ev)
    fgMatte = lumaClip(fg, lo, hi)
    scaled_fg = fg * exposureFactor * fgMatte
    return (bg * (1.0 - fgMatte)) + scaled_fg

if __name__ == '__main__':
    args = getargv()
    files = getFiles(args['input_dir'])
    # Sanity checks
    assert (len(files) % args['chunk']) == 0, 'Input file list is not a multiple of chunk size: %i' % args['chunk']
    assert args['center'] < args['chunk'], "'center' image index exceeds size of chunks! (center:%i chunks: %i)" % (args['center'], args['chunk'])

    if not os.path.isdir(args['output_dir']):
        print "Creating output directory (%s)" % args['output_dir']
	os.mkdir(args['output_dir'])

    # Various ways to call dcraw
    if args['verbose_dcraw']:
        DCRAW = 'dcraw -v -q 3 -4 -w -c ' + ROTATE
    else:
        DCRAW  = 'dcraw -q 3 -4 -w -c ' + ROTATE
        
    stacks = list(chunk(files, args['chunk']))
    # Finally... let's process some files!
    for stackIndex, stack in enumerate(stacks):
        cmdlist = []
        tmplist = []
        for f in stack:
            crap, fname = os.path.split(f)
	    temp_fname  =f.split('/')[-1]+'.PPM'
            tmp_path = os.path.join(TEMP_DIR, temp_fname)
            cmd = DCRAW + f + ' > ' + tmp_path

	    # TODO: This tmplist stuff should be replaced with tempfile at some point
            cmdlist.append(cmd)
            tmplist.append(tmp_path)
        print 'Processing stack:'+str(stackIndex+1)+'/'+str(len(stacks))
        print 'Debayering...'

	# Parallell process the debayering via dcraw
        pool = Pool(processes=MAX_WORKERS) 
        pool.map(sh, cmdlist)
        pool.close()

	# Open each PPM file
        layers = [ PPM(file(fileIn, 'rb')) for fileIn in tmplist ]
        meta = getMeta(stack[args['center']-1])

	width, height = layers[0].w, layers[0].h
        HEADER = OpenEXR.Header(width, height)
        HEADER['channels'] = dict([(c, Imath.Channel(Imath.PixelType(Imath.PixelType.HALF))) for c in HEADER['channels'].keys()])
        HEADER['comments'] = 'Made with rawtohdri ' + VERSION + ' by Aaron Estrada'

	for label in ['camera', 'date', 'iso', 'aperture', 'shutter', 'focal']:
		HEADER[label] = meta[label]

	outfile_name = args['output_basename'] % (stackIndex + 1)
        OUTFILE = os.path.join(args['output_dir'], outfile_name)

        exr = OpenEXR.OutputFile(OUTFILE, HEADER)
        print 'Starting HDR stacking of',len(stack), width,'x', height, 'resolution images ...'
        bg = layers.pop(0)
        
        for lindex, output in enumerate(bg):
            ev = args['ev']
            for layer in layers:        
                output = hdrStackLines(output, layer.readline(), ev, args['lo'], args['hi'])
                ev = ev + args['ev']

            #Adjust output to "center" exposure.
            output = output*(2.0**(xrange(0,999999,args['ev'])[args['center']-1]))
            R, G, B = np.column_stack(output.reshape([len(output) / 3, 3]).astype(np.float16))
            sys.stdout.write("\r Writing Scanline: ")
            sys.stdout.write(str(lindex+1))
            sys.stdout.flush()
            exr.writePixels({'R': R.tostring(), 'G': G.tostring(), 'B': B.tostring()}, 1)
        
        bg.close()
        for ppm in layers: ppm.close()
        exr.close()
        print ' ... DONE!'
        print '  Wrote', OUTFILE     
        print '   Blowing away temp files...'
        for tmpFile in tmplist: os.remove(tmpFile)
        
    print 'Finished processing '+str(len(files))+' raw files into '+str(len(stacks))+' HDRIs'

